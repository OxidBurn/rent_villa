---
name: Sentry Error Tracking
status: completed
created: 2025-10-30T17:15:07Z
updated: 2025-10-31T02:18:00Z
epic: complete-development-pipeline-setup
depends_on: [3]
parallel: true
conflicts_with: []
effort: 4-5 hours
priority: P1
---

# Task 007: Sentry Error Tracking

## Objective

Integrate Sentry for real-time error tracking and performance monitoring in both client-side and server-side Next.js code, configure source maps for production debugging, and test error reporting flows.

## Context

This task establishes production error monitoring for Rent Villa. Sentry provides real-time visibility into errors, exceptions, and performance issues, enabling rapid diagnosis and resolution of production problems.

## Dependencies

**Hard Dependencies:**

- Task 002: Vercel Deployment Setup (required for production environment)

**Parallel Execution:**

- Can be worked on independently once Vercel deployment is configured
- Does not conflict with other tasks

## Scope

### In Scope

- Create Sentry project and organization
- Install and configure Sentry SDK for Next.js
- Integrate Sentry in client-side code (browser)
- Integrate Sentry in server-side code (API routes, server components)
- Configure source map upload for production builds
- Set up environment-specific error tracking
- Create error boundary components
- Test error reporting in staging
- Configure alert rules for critical errors
- Document error monitoring workflow

### Out of Scope

- Performance monitoring (defer to Phase 2)
- Custom error dashboards (use Sentry defaults)
- Error rate alerting to Slack/email (defer to Phase 2)
- User feedback widget (defer to Phase 2)
- Session replay (defer to Phase 2)
- Advanced sampling rules (use defaults)

## Implementation Plan

### Step 1: Create Sentry Project (20 minutes)

**Sign up for Sentry:**

1. Go to [sentry.io](https://sentry.io)
2. Create free account
3. Create organization: `rent-villa`
4. Create project: `rent-villa-nextjs`
5. Select platform: `Next.js`
6. Note DSN keys:
   - Client DSN: `https://xxx@xxx.ingest.sentry.io/xxx`
   - Server DSN: (same as client for Next.js)

**Configure environment:**

```
Production: rent-villa-production
Staging: rent-villa-staging
Development: rent-villa-development
```

### Step 2: Install Sentry SDK (15 minutes)

**Install dependencies:**

```bash
npx @sentry/wizard@latest -i nextjs
```

This wizard will:

- Install `@sentry/nextjs` package
- Create Sentry configuration files
- Add Sentry to Next.js config
- Set up source maps

**Manual installation (if wizard fails):**

```bash
npm install @sentry/nextjs
```

### Step 3: Configure Sentry (45 minutes)

**Create Sentry config:** `sentry.client.config.ts`

```typescript
import * as Sentry from '@sentry/nextjs'

const SENTRY_DSN = process.env.NEXT_PUBLIC_SENTRY_DSN

Sentry.init({
  dsn: SENTRY_DSN,

  environment: process.env.NEXT_PUBLIC_VERCEL_ENV || 'development',

  tracesSampleRate: 0.1,

  beforeSend(event, hint) {
    if (process.env.NODE_ENV === 'development') {
      console.error('Sentry Event:', event, hint)
      return null
    }
    return event
  },

  integrations: [Sentry.browserTracingIntegration()],

  ignoreErrors: ['ResizeObserver loop limit exceeded', 'Non-Error promise rejection captured'],
})
```

**Create server config:** `sentry.server.config.ts`

```typescript
import * as Sentry from '@sentry/nextjs'

const SENTRY_DSN = process.env.SENTRY_DSN

Sentry.init({
  dsn: SENTRY_DSN,

  environment: process.env.VERCEL_ENV || 'development',

  tracesSampleRate: 0.1,

  beforeSend(event, hint) {
    if (process.env.NODE_ENV === 'development') {
      console.error('Sentry Event:', event, hint)
      return null
    }
    return event
  },

  integrations: [Sentry.httpIntegration()],
})
```

**Create edge config:** `sentry.edge.config.ts`

```typescript
import * as Sentry from '@sentry/nextjs'

const SENTRY_DSN = process.env.SENTRY_DSN

Sentry.init({
  dsn: SENTRY_DSN,
  environment: process.env.VERCEL_ENV || 'development',
  tracesSampleRate: 0.1,
})
```

**Update Next.js config:** `next.config.ts`

```typescript
import { withSentryConfig } from '@sentry/nextjs'

const nextConfig = {
  // ... existing config
}

export default withSentryConfig(nextConfig, {
  org: 'rent-villa',
  project: 'rent-villa-nextjs',

  silent: !process.env.CI,

  widenClientFileUpload: true,

  hideSourceMaps: true,

  disableLogger: true,

  automaticVercelMonitors: true,
})
```

### Step 4: Add Environment Variables (15 minutes)

**Add to Vercel environment variables:**

Production:

```
SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx
NEXT_PUBLIC_SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx
SENTRY_AUTH_TOKEN=<from Sentry settings>
SENTRY_ORG=rent-villa
SENTRY_PROJECT=rent-villa-nextjs
```

Staging:

```
SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx
NEXT_PUBLIC_SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx
SENTRY_AUTH_TOKEN=<from Sentry settings>
SENTRY_ORG=rent-villa
SENTRY_PROJECT=rent-villa-nextjs
```

**Add to `.env.local` (development):**

```
SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx
NEXT_PUBLIC_SENTRY_DSN=https://xxx@xxx.ingest.sentry.io/xxx
```

**Add to `.gitignore`:**

```
# Sentry
.sentryclirc
sentry.properties
```

### Step 5: Create Error Boundary (30 minutes)

**Create error boundary component:** `src/components/ErrorBoundary.tsx`

```typescript
'use client';

import * as Sentry from '@sentry/nextjs';
import { useEffect } from 'react';

export default function ErrorBoundary({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    Sentry.captureException(error);
  }, [error]);

  return (
    <div className="flex min-h-screen flex-col items-center justify-center p-4">
      <div className="w-full max-w-md space-y-4 text-center">
        <h2 className="text-2xl font-bold">Something went wrong!</h2>
        <p className="text-gray-600">
          We've been notified and are working to fix the issue.
        </p>
        {error.digest && (
          <p className="text-sm text-gray-500">Error ID: {error.digest}</p>
        )}
        <button
          onClick={reset}
          className="rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600"
        >
          Try again
        </button>
      </div>
    </div>
  );
}
```

**Add error boundary to app:** `src/app/error.tsx`

```typescript
import ErrorBoundary from '@/components/ErrorBoundary'

export default ErrorBoundary
```

**Add global error boundary:** `src/app/global-error.tsx`

```typescript
'use client';

import * as Sentry from '@sentry/nextjs';
import { useEffect } from 'react';

export default function GlobalError({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    Sentry.captureException(error);
  }, [error]);

  return (
    <html>
      <body>
        <div className="flex min-h-screen flex-col items-center justify-center">
          <h2>Application Error</h2>
          <button onClick={reset}>Try again</button>
        </div>
      </body>
    </html>
  );
}
```

### Step 6: Create Test Error Routes (30 minutes)

**Create client error test:** `src/app/api/sentry-example-client/route.ts`

```typescript
export async function GET() {
  throw new Error('Sentry Example Client Error')
}
```

**Create server error test:** `src/app/api/sentry-example-server/route.ts`

```typescript
export const dynamic = 'force-dynamic'

export async function GET() {
  throw new Error('Sentry Example Server Error')
}
```

**Create test page:** `src/app/test-sentry/page.tsx`

```typescript
'use client';

import * as Sentry from '@sentry/nextjs';

export default function TestSentryPage() {
  const testClientError = () => {
    throw new Error('Test Client Error');
  };

  const testServerError = async () => {
    await fetch('/api/sentry-example-server');
  };

  const testManualCapture = () => {
    Sentry.captureMessage('Test manual message', 'info');
  };

  return (
    <div className="p-8 space-y-4">
      <h1 className="text-2xl font-bold">Sentry Error Testing</h1>

      <div className="space-x-4">
        <button
          onClick={testClientError}
          className="rounded bg-red-500 px-4 py-2 text-white"
        >
          Test Client Error
        </button>

        <button
          onClick={testServerError}
          className="rounded bg-orange-500 px-4 py-2 text-white"
        >
          Test Server Error
        </button>

        <button
          onClick={testManualCapture}
          className="rounded bg-blue-500 px-4 py-2 text-white"
        >
          Test Manual Capture
        </button>
      </div>

      <p className="text-sm text-gray-600">
        Check Sentry dashboard after clicking buttons
      </p>
    </div>
  );
}
```

### Step 7: Configure Source Maps (20 minutes)

**Create Sentry auth token:**

1. Go to Sentry → Settings → Auth Tokens
2. Create new token with `project:releases` scope
3. Add to Vercel environment variables as `SENTRY_AUTH_TOKEN`

**Verify source map configuration in `next.config.ts`:**

```typescript
export default withSentryConfig(nextConfig, {
  silent: !process.env.CI,
  widenClientFileUpload: true,
  hideSourceMaps: true,
  disableLogger: true,
})
```

**Test source map upload:**

```bash
npm run build
```

Check build output for Sentry upload confirmation.

### Step 8: Documentation (45 minutes)

**Create monitoring guide:** `docs/error-monitoring.md`

````markdown
# Error Monitoring Guide

## Overview

Rent Villa uses Sentry for real-time error tracking and monitoring in production.

## Sentry Dashboard

Access: [https://sentry.io/organizations/rent-villa](https://sentry.io/organizations/rent-villa)

**Key Sections:**

- **Issues:** All errors grouped by type
- **Performance:** Transaction monitoring
- **Releases:** Deploy tracking
- **Alerts:** Configured alerts

## Error Tracking

### Automatic Error Capture

Errors are automatically captured in:

- Client-side JavaScript errors
- Server-side API route errors
- Unhandled promise rejections
- React error boundaries

### Manual Error Capture

Capture custom errors or messages:

```typescript
import * as Sentry from '@sentry/nextjs'

try {
  riskyOperation()
} catch (error) {
  Sentry.captureException(error)
  throw error
}

Sentry.captureMessage('Something noteworthy happened', 'info')
```
````

### Adding Context

Add user context:

```typescript
Sentry.setUser({
  id: user.id,
  email: user.email,
  username: user.name,
})
```

Add custom tags:

```typescript
Sentry.setTag('page', 'properties')
Sentry.setTag('feature', 'booking')
```

Add breadcrumbs:

```typescript
Sentry.addBreadcrumb({
  category: 'booking',
  message: 'User initiated booking',
  level: 'info',
})
```

## Error Response Workflow

### When Error Occurs

1. **Sentry captures error** automatically
2. **User sees error boundary** with friendly message
3. **Team receives notification** (if alert configured)
4. **Developer investigates** in Sentry dashboard

### Investigating Errors

1. Open error in Sentry dashboard
2. Review stack trace (source maps show original code)
3. Check user context and breadcrumbs
4. Review similar errors
5. Check if error is new or recurring
6. Assign to team member

### Resolving Errors

1. Fix bug in code
2. Deploy fix
3. Mark issue as resolved in Sentry
4. Monitor for recurrence

## Testing Error Tracking

### Local Testing

Visit: `http://localhost:3000/test-sentry`

Click buttons to trigger test errors.

### Staging Testing

Deploy to staging and test error reporting.

## Best Practices

1. **Don't capture sensitive data:**
   - Sanitize user input before logging
   - Don't log passwords, tokens, or PII

2. **Add context to errors:**
   - Use tags for categorization
   - Add breadcrumbs for user flow
   - Include user IDs (non-PII)

3. **Handle errors gracefully:**
   - Show user-friendly error messages
   - Provide recovery actions (reset button)
   - Don't expose technical details

4. **Resolve stale issues:**
   - Review issues weekly
   - Archive non-actionable errors
   - Ignore known third-party errors

## Environment Configuration

### Development

- Errors logged to console only
- Not sent to Sentry (to avoid noise)

### Staging

- All errors sent to Sentry
- Environment: `staging`

### Production

- All errors sent to Sentry
- Environment: `production`
- Source maps uploaded

## Troubleshooting

**Errors not appearing in Sentry:**

- Check DSN is configured
- Verify environment is not development
- Check browser console for Sentry errors

**Source maps not working:**

- Verify SENTRY_AUTH_TOKEN is set
- Check build logs for upload confirmation
- Ensure release matches deployed version

**Too many errors:**

- Adjust sample rate in sentry.config.ts
- Add to ignoreErrors array
- Review and fix root causes

````

### Step 9: Validation (30 minutes)

**Local validation:**
```bash
# Run development server
npm run dev

# Visit test page
open http://localhost:3000/test-sentry

# Trigger test errors
# Check console (errors should log but not send)
````

**Staging validation:**

```bash
# Deploy to staging
vercel --prod=false

# Visit test page
open https://staging-url.vercel.app/test-sentry

# Trigger test errors
# Check Sentry dashboard for captured errors
```

**Verify source maps:**

1. Trigger error in staging
2. Open error in Sentry
3. Verify stack trace shows original TypeScript code

## Technical Decisions

### Decision 1: Sentry Over Alternatives

**Rationale:**

- Industry standard error tracking
- Excellent Next.js integration
- Generous free tier (5k errors/month)
- Source map support out of the box

**Alternative Considered:** Bugsnag, Rollbar
**Why Not:** Smaller community, less Next.js focus

### Decision 2: Automatic Source Map Upload

**Rationale:**

- Essential for production debugging
- Sentry Next.js SDK handles automatically
- No manual upload process needed

**Alternative Considered:** Manual source map upload
**Why Not:** Error-prone, extra steps

### Decision 3: Separate Environments

**Rationale:**

- Filter errors by environment
- Different alert rules per environment
- Avoid development noise

**Alternative Considered:** Single environment for all
**Why Not:** Hard to separate production issues from test errors

## Acceptance Criteria

- [ ] Sentry project created
- [ ] Sentry SDK installed and configured
- [ ] Client-side error tracking working
- [ ] Server-side error tracking working
- [ ] Error boundary components created
- [ ] Source maps uploading successfully
- [ ] Environment variables configured in Vercel
- [ ] Test error routes created
- [ ] Error reporting tested in staging
- [ ] Documentation created

## Definition of Done

- ✅ All acceptance criteria met
- ✅ Code reviewed and approved
- ✅ Tested in staging environment
- ✅ Documentation reviewed
- ✅ Team walkthrough completed (15 min demo)
- ✅ Test errors verified in Sentry dashboard

## Effort Estimate

**Total: 4-5 hours**

- Sentry project setup: 0.5 hour
- SDK installation and config: 1-1.5 hours
- Error boundary creation: 0.5 hour
- Test routes: 0.5 hour
- Source map configuration: 0.5 hour
- Documentation: 1 hour
- Validation and testing: 0.5-1 hour

**Complexity:** Small-Medium
**Risk Level:** Low (well-documented SDK)

## Notes

### Success Metrics

- 100% of errors captured in production
- <1 minute from error to Sentry notification
- Source maps working for all errors

### Future Enhancements (Post-Epic)

- Performance monitoring
- Session replay
- User feedback widget
- Slack/email alerts
- Custom error dashboards
- Error rate trends

### Common Pitfalls to Avoid

- Don't capture sensitive user data
- Don't ignore error context (add tags/breadcrumbs)
- Don't leave errors unresolved indefinitely
- Don't over-alert (causes alert fatigue)
- Don't test in production (use staging)

### Resources

- [Sentry Next.js Documentation](https://docs.sentry.io/platforms/javascript/guides/nextjs/)
- [Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
- [Sentry Best Practices](https://docs.sentry.io/product/best-practices/)
